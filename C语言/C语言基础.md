# C语言基础学习
```
内存中数据的存储
内存条是一个非常精密的部件，包含了上亿个电子元器件，它们很小，达到了纳米级别。
这些元器件，实际上就是电路；电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压。
5V 是通电，用1来表示，0V 是断电，用0来表示。所以，一个元器件有2种状态，0 或者 1。
1个元器件称为1比特（Bit）或1位，8个元器件称为1字节（Byte），那么16个元器件就是2Byte，32个就是4Byte，以此类推：
8×1024个元器件就是1024Byte，简写为1KB；
8×1024×1024个元器件就是1024KB，简写为1MB；
8×1024×1024×1024个元器件就是1024MB，简写为1GB。
```

## C语言变量及类型
在定义变量时还要指明数据的长度。而这恰恰是数据类型的另外一个作用。
数据类型除了指明数据的解释方式，还指明了数据的长度。因为在C语言中，每一种数据类型所占用的字节数都是固定的，知道了数据类型，也就知道了数据的长度。

![alt text](./imgs/1492151997(1.png "")

### 整数&浮点数

```C
#include <stdio.h>
int main()
{
    short a = 10;
    int b = 100;
    long c = 1000;
    char d = 'X';
   
    int a_length = sizeof a;
    int b_length = sizeof(int);
    printf("a=%d, b=%d, c=%d, d=%d\n", a_length, b_length, sizeof(c), sizeof(char));
    return 0;
}
```

__在符号位中，用0表示正数，用1表示负数。__
例如 int 类型的 -10、+16 在内存中的表示如下：

![alt text](./imgs/1-16053015203OD.jpg "")

当数值过大或过小时，有限的几个字节就不能表示，就会发生溢出。发生溢出时，最高位会被截去。

```C
#include <stdio.h>
int main()
{
    unsigned int a = 0x100000000;
    int b = 0xffffffff;
    printf("a=%u, b=%d\n", a, b);
    return 0;
}
```

__计算机中，数值一律采用补码形式表示。__
+ 正数补码，反码就是其原码，正数的原码就是其二进制
+ 负数补码是其反码+1，负数的反码是将原码中除符号位以外的每一位取反
例如，16-9 = 16+(-9)，16 的补码为 0001 0000，-9 的原码为 1000 1001，补码为 1111 0111。我们可以直接将两个数的补码相加：
```
1111 0111 + 0001 0000 = 1 0000 0111
```
最高位的1溢出，被截去，内存中最后剩下 0000 0111，也就是7。

__%f 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。__

![alt text](./imgs/1-1601021422192L.png "")

+ float和double的精度是由尾数的位数来决定的。
+ float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即 float 的精度为 6~7 位有效数字。
+ double：2^52 = 4503599627370496，一共16位，同理，double 的精度为 15~16 位。
+ float 的取值范围为 -2^128 ~ +2^128，也即 -3.40E+38 ~ +3.40E+38
+ double 的取值范围为 -2^1024 ~ +2^1024，也即 -1.79E+308 ~ +1.79E+308

__C语言把整数作为定点数，而把小数作为浮点数。定点数必须转换为补码再写入内存，浮点数没有这个过程，直接写入原码。__

### 字符

单引号引起来的叫字符，双引号引起来的叫字符串
printf 格式控制字符的完整形式如下：
```
%[flags][width][.precision]type
```
对于整数和小数，默认右对齐，不足的宽度以空格补齐，例如：
```C
printf("%10d%12f", 234, 9.8);//-左对齐
```
scanf()是带有缓冲区的
```C
int a=0, b=0;
scanf("a=%d", &a);
scanf("b=%d", &b);
printf("a=%d, b=%d\n", a, b);
```
遇到 scanf() 函数，程序会先检查输入缓冲区中是否有数据，如果没有，就等待用户输入
用户输入的每个字符都会保存到缓冲区，直到按下回车键，输入结束
__注：当控制字符串不是以%开头时候，回车换行符就起作用了，scanf() 会对它进行匹配，只是匹配失败而已。__

### 结构&运算符
+ 非0数值，逻辑值都是1，数值为0，逻辑值为0

### 数组
+ 当赋值的元素少于数组总体元素的时候，剩余的元素自动初始化为 0：对于short、int、long，就是整数0；对于char，就是字符 '\0'；对于float、double，就是小数0.0。
+ 用字符串给字符数组赋值时由于要添加结束符 '\0'，数组的长度要比字符串的长度（字符串长度不包括 '\0'）大1
```C
char str2[] = "C Language";
char str3[] = {'C',' ','L','a','n','g','u','a','g','e'};

printf("%d\n",sizeof(str2));
printf("%d\n",strlen(str2));
printf("==========\n");
printf("%d\n",sizeof(str3));
printf("%d\n",strlen(str3));
```
+ scanf 的各个变量前面要加取地址符&，用以获得变量的地址，数组名所代表的地址为第0个元素的地址，例如char c[10];，c就代表c[0]的地址。第0个元素的地址就是数组的起始地址，称为首地址。也就是说，数组名表示数组的首地址，所以在c前面不能再加取地址符&。

### 宏
+ 带参数的宏和函数很相似，但有本质上的区别：宏展开仅仅是字符串的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存。而函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数，就是执行这块内存中的代码。
+ 宏定义中字符串化操作符#：#的功能是将其后面的宏参数进行字符串化操作，意思就是对它所应用的宏变量通过替换后在其左右各加上一个双引号。
```C
#define DEMO(s)\
do {\
	if(s) {\
		printf("this is a test#s");\
	}\
} while(0)
```
+ 宏定义中的连接符##：连接符##用来将两个token连接为一个token，但它不可以位于第一个token之前or最后一个token之后。注意这里连接的对象只要是token就行，而不一定是宏参数,但是##又必须位于宏定义中才有效，因其为编译期概念
```C
#define PARSER(N) printf("token" #N " = %d\n", token##N)
int token64 = 64;

//调用
PARSER(64);
//解析为：
printf("token" "64" " = %d\n", token64);
```
+ 这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能
```C
#if _WIN32
	system("color 0c");
	printf("http://c.biancheng.net\n");
#elif __linux__
	printf("\033[22;31mhttp://c.biancheng.net\n\033[22;30m");
#else
	printf("http://c.biancheng.net\n");
#endif
```
+ #if 后面跟的是“整型常量表达式”，而 #ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的
+ #ifdef 可以认为是 #if defined 的缩写
```C
#ifdef M
#if (defined NUM1 && defined NUM2)
```

## C语言变成环境
+ 头文件查找
    使用<>，首先检索标准路径，如果没有，不会检索当前路径
    使用""，首先检索当前路径，如果没有，检索标准路径
    linux下，上述标准路径有：/usr/include，/usr/local/include

